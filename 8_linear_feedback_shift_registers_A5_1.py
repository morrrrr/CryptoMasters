def gen_next_key_by_coefs(_current_key, coefs):
    sum_current_state_registers_by_coefficients = 0
    # calculate the sum of registers using the coefficients
    for idx, coeff in enumerate(coefs):
        if coeff == 1:
            sum_current_state_registers_by_coefficients += _current_key[idx]
 
    # the new register value is equal to the sum % 2
    new_value = sum_current_state_registers_by_coefficients % 2
    # shift the existing state and include the newly calculated bit
    return [_current_key[1], _current_key[2], _current_key[3], _current_key[4], _current_key[5], _current_key[6],
            _current_key[7], new_value]
 
 
# Used to shift the bits in the key by n positions -> to generate a completely new 8 bit number you shift by 8
def shift_n_keys(current_key, polynomial, n):
    tmp_key = current_key
    for i in range(n):
        tmp_key = gen_next_key_by_coefs(tmp_key, polynomial)
    return tmp_key
 
 
def binary_array_to_integer(bin_array):
    result = 0
    for idx, num in enumerate(reversed(bin_array)):
        result += num * (2 ** idx)
    return result
 
 
# Given in the practice task
# cipherText = [9, 109, 181, 206, 184, 82, 223, 24, 198, 51, 40, 142, 7, 238, 195, 135, 183, 116, 63, 187, 231, 70, 246,
#               233, 99, 15, 82, 78, 119, 144, 62, 9, 123, 172, 220, 191, 90, 211, 31, 217, 36, 52, 143, 31, 244, 221,
#               148, 191, 125, 57, 176, 229, 78, 229, 228, 97, 19, 79, 80, 104, 156, 32, 22, 99, 178, 217, 162, 67, 207,
#               25, 200, 53, 40, 144, 9, 232, 192, 156, 161, 100, 44, 183, 255, 66, 232, 233, 98, 28, 79, 76, 109, 156,
#               63, 28, 107, 166, 218, 170, 94, 206, 26, 198, 55, 40, 149, 26, 239, 221, 156, 190, 125, 44, 174, 240, 66,
#               237, 228, 100, 18, 79, 81, 105, 128, 38, 11, 114, 166, 220, 191, 66, 195, 1, 215, 32, 46, 140, 26, 252,
#               195]
#
# def encrypt_decrypt_using_lfsr():
#     # setting the initial state of the registers
#     seed_key = [0, 1, 0, 1, 1, 1, 1, 1]
#     # the coefficients of the registers, could be expressed as a polynomial y = x1 + x2 + x4 + x5 + x7
#     poly = [1, 1, 0, 1, 1, 0, 1, 0]
#     prev_key = seed_key
#     resulting_text = ''
#
#     # The usage of LFSR generated keystream for encryption/decryption is a simple XOR operation for each of the
#     # symbols of the text
#
#     # For each symbol in the text, that is represented as an array of integers instead of chars
#     for c in cipherText:
#         # calculate an integer key value from the 8bit binary array
#         key_to_use = binary_array_to_integer(prev_key)
#         # xor the single character integer with the key
#         xored_number = c ^ key_to_use
#         # store the ASCII character of the calculated position as a result
#         resulting_text += chr(xored_number)
#         # generate the key for the next symbol by shifting the used key by 8 positions
#         prev_key = shift_n_keys(prev_key, poly, 8)
#     print(resulting_text)
#
# encrypt_decrypt_using_lfsr()
# ###########################333
# From here up - simple Linear feedback shift register example
 
def integer_to_len8_bin_array(num):
    if num > 255:
        print("no way")
        return False
 
    arr = [int(x) for x in bin(num)[2:]]
    while len(arr) != 8:
        arr.insert(0, 0)
 
    return arr
 
 
# A5/1 combines 3 simple LFSRs
# The key bit is generated by XOR of the leftmost bits from the registers
# This time instead of clocking all the registers each time, a voting mechanism is introduced:
# each register has a 'voting' bit and it is shifted only if this voting bit agrees with the majority of other
# registers' voting bits, for example if two registers have voting bits 0 and one has voting bit 1, so only the
# two registers with the voting bit equal to 0 will be shifted. So this way at each step either two or all three
# registers are shifted.
 
# calculating the majority bit value by getting the values of the 'voting' bits in each register
def get_majority_value(registers_list, control_bits):
    result = 0
    for index, ctrl_idx in enumerate(control_bits):
        result += registers_list[index][ctrl_idx]
 
    if result > (len(registers_list) / 2):
        return 1
    return 0
 
 
# shifting the register only if its voting bit agrees with the majority value
def tick_register(register, polynomial, ctrl_idx, majority_value):
    if register[ctrl_idx] == majority_value:
        return gen_next_key_by_coefs(register, polynomial)
    return register
 
 
# simply ticking all the registers
def tick_registers(registers, polynomial_list, ctrl_indices, majority_value):
    return list(map(lambda r, c, y: tick_register(r, c, y, majority_value), registers, polynomial_list, ctrl_indices))
 
 
def calculate_next_state(registers, polynomial_list, ctrl_indices):
    majority = get_majority_value(registers, ctrl_indices)
    return tick_registers(registers, polynomial_list, ctrl_indices, majority)
 
 
# the output bit is calculated by xoring the leftmost bits of each register
def get_output_bit(registers):
    res = 0
    for register in registers:
        res = res ^ register[0]
    return res
 
 
# simply generating bits_count bits, also accepting initial state of the registers
# for example 8 bits, that could be used in generation for a key of 8 bit integers
def generate_a5_bits(bits_count, initial_registers, polynomials, ctrl_indices):
    registers = initial_registers
    result = []
 
    for i in range(bits_count):
        result.append(get_output_bit(registers))
        registers = calculate_next_state(registers, polynomials, ctrl_indices)
    # the return value is not only the single n bits result, but also the registers state, so it could be
    # used in further key generation
    return [result, registers]
 
 
# generating a full length key of 8bit integers to be used for the given length text
def a5_1_key(bytes_count, initial_registers, polynomials, ctrl_indices):
    registers = initial_registers
    result = []
 
    for i in range(bytes_count):
        [single_byte, next_state] = generate_a5_bits(8, registers, polynomials, ctrl_indices)
        registers = next_state
        result.append(binary_array_to_integer(single_byte))
    return result
 
 
def example_decrypt_a5_1():
    # given ciphertext from the practice exercise
    cipher_2 = [127, 122, 123, 234, 182, 27, 190, 176, 39, 95, 8, 23, 43, 192, 113, 69, 53, 253, 142, 255, 2, 138, 83, 159, 114, 127, 220, 82, 169, 136, 193, 245, 47, 108, 225, 161, 21, 182, 168, 37, 65, 8, 10, 39, 205, 113, 90, 54, 226, 136, 255, 22, 150, 76, 159, 119, 113, 217, 86, 169, 147, 204, 238, 58, 120, 248, 175, 25, 162, 180, 55, 92, 3, 21, 39, 206, 121, 88, 36, 251, 159, 237, 19, 142, 91, 159, 111, 103, 220, 75, 173, 143, 193, 224, 50, 120, 225, 175, 29, 188, 173, 35, 67, 8, 3, 58, 205, 108, 83, 36, 251, 143, 247, 23, 155, 86, 147, 106, 126, 220, 82, 173, 142, 193, 243, 34, 126, 226]
    seed_key = [0, 1, 0, 1, 1, 1, 1, 1]
    poly = [1, 1, 0, 1, 1, 0, 1, 0]
    ctrl_indices = [1, 2, 3]
 
    initial_registers = [seed_key, seed_key, seed_key]
    polynomial_list = [poly, poly, poly]
 
    # generating the same length key as the text to be encrypted/decrypted
    keys_list = a5_1_key(len(cipher_2), initial_registers, polynomial_list, ctrl_indices)
    plaintext_2 = ''
 
    for i, c in enumerate(cipher_2):
        # simple XOR operation on each symbol
        plain_numb = c ^ keys_list[i]
        plaintext_2 += chr(plain_numb)
    print(plaintext_2)
 
example_decrypt_a5_1()
 
# PAVARGO MELAGELIO BOTAGELIS KITA KARTA JEIGU GRAZIAI PAPRASYSI VEL PAPLIAUSKESIU O JEIBARSIES VADINSI MELAGIU J KAMPAPA STATYSIU IR TIEK JI TEMATYSI